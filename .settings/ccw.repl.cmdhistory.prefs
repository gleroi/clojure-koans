cmdhistory=["(subvec [\:pea \:but \:and \:jel] 1 3)" "(reduce (fn [a b]\\r\\n                         (if (< a b) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])" "(reduce (fn [a b]\\r\\n                         (if (< (count a) (count b)) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])" "(meditations\\r\\n  \\"The map function relates a sequence to another\\"\\r\\n  (\= [4 8 12] (map (fn [x] (* 4 x)) [1 2 3]))\\r\\n\\r\\n  \\"You may create that mapping\\"\\r\\n  (\= [1 4 9 16 25] (map (fn [x] (* x x)) [1 2 3 4 5]))\\r\\n\\r\\n  \\"Or use the names of existing functions\\"\\r\\n  (\= [false false true false false] (map nil? [\:a \:b nil \:c \:d]))\\r\\n\\r\\n  \\"A filter can be strong\\"\\r\\n  (\= '() (filter (fn [x] false) '(\:anything \:goes \:here)))\\r\\n\\r\\n  \\"Or very weak\\"\\r\\n  (\= '(\:anything \:goes \:here) (filter (fn [x] true) '(\:anything \:goes \:here)))\\r\\n\\r\\n  \\"Or somewhere in between\\"\\r\\n  (\= [10 20 30] (filter (fn [x] (< x 31)) [10 20 30 40 50 60 70 80]))\\r\\n\\r\\n  \\"Maps and filters may be combined\\"\\r\\n  (\= [10 20 30] (map (fn [x] (* x 10)) (filter (fn [x] (< x 4)) [1 2 3 4 5 6 7 8])))\\r\\n\\r\\n  \\"Reducing can increase the result\\"\\r\\n  (\= 24 (reduce (fn [a b] (* a b)) [1 2 3 4]))\\r\\n\\r\\n  \\"You can start somewhere else\\"\\r\\n  (\= 2400 (reduce (fn [a b] (* a b)) 100 [1 2 3 4]))\\r\\n\\r\\n  \\"Numbers are not the only things one can reduce\\"\\r\\n  (\= \\"longest\\" (reduce (fn [a b]\\r\\n                         (if (< (count a) (count b)) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])))" "(inc 5)" "(defn recursive-reverse [coll]\\r\\n  (conj (first coll) (recursive-reverse (rest coll))))" "(recursive-reverse [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty coll)\\r\\n    coll\\r\\n    (conj (first coll) (recursive-reverse (rest coll)))))" "(recursive-reverse [1 2 3 4 5])" "(empty [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    coll\\r\\n    (conj (first coll) (recursive-reverse (rest coll)))))" "(recursive-reverse [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    coll\\r\\n    (conj (recursive-reverse (rest coll)) (first coll))))" "(recursive-reverse [1 2 3 4 5])" "(conj '(1 2 3) 4)" "(conj 4 '(1 2 3))" "(cons 4 '(1 2 3))" "(conj '(1 2 3) '(4 5 6))" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    '()\\r\\n    (concat (recursive-reverse (rest coll)) (first coll))))" "(recursive-reverse [1])" "(factorial 100003N)" "\\r\\n(defn factorial [n]\\r\\n  (if (\= n 1)\\r\\n    1\\r\\n    (* n (factorial (dec n)))))" "(factorial 100003N)" "((fn [[a b]] (str b a))\\r\\n         [\:foo \:bar])" "((fn [[a b c]] (str \\"First come \\" a \\", then comes \\" b \\", then comes \\" c \\" with baby carriage\\"))\\r\\n      [\\"love\\" \\"marriage\\" \\"Clojure\\"])" "((fn [[a b c]] (str \\"First comes \\" a \\", then comes \\" b \\", then comes \\" c \\" with baby carriage\\"))\\r\\n      [\\"love\\" \\"marriage\\" \\"Clojure\\"])" "(str \\"First comes love, \\"\\r\\n          \\"then comes marriage, \\"\\r\\n          \\"then comes Clojure with the baby carriage\\")" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name last-name (clojure.string/join aliases \\" aka \\")))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name last-name (clojure.string/join \\" aka \\" aliases)))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name \\" \\" last-name (clojure.string/join \\" aka \\" aliases)))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name \\" \\" last-name \\" \\" (clojure.string/join \\" aka \\" aliases)))" "(let [{street-address \:street-address, city \:city, state \:state} test-address]\\r\\n       (str (clojure.string/join \\", \\" [street-address city state])))" "(let [{\:keys [street-address city state]} test-address]\\r\\n       (clojure.string/join \\", \\" (map (fn [a] (test-address a)))))" "(def test-address\\r\\n  {\:street-address \\"123 Test Lane\\"\\r\\n   \:city \\"Testerville\\"\\r\\n   \:state \\"TX\\"})" "(let [{\:keys [street-address city state]} test-address]\\r\\n       (clojure.string/join \\", \\" (map (fn [a] (test-address a)))))" "(str [\\"Test\\" \\"Testerson\\"] test-address)" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\r\\n          (clojure.string/join \\", \\"(\:values test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\"(\:values test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\" (vals test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\" (sort (vals test-address))))" "(let [exclamator (fn [x] (str x \\"\!\\"))]\\r\\n          (dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world)" "(def the-world (ref \\"hello\\"))\\r\\n(def bizarro-world (ref {}))" "(dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world" "(let [exclamator (fn [x] (str x \\"\!\\"))]\\r\\n          (dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world)"]
eclipse.preferences.version=1
