cmdhistory=["(subvec [\:pea \:but \:and \:jel] 1 3)" "(reduce (fn [a b]\\r\\n                         (if (< a b) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])" "(reduce (fn [a b]\\r\\n                         (if (< (count a) (count b)) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])" "(meditations\\r\\n  \\"The map function relates a sequence to another\\"\\r\\n  (\= [4 8 12] (map (fn [x] (* 4 x)) [1 2 3]))\\r\\n\\r\\n  \\"You may create that mapping\\"\\r\\n  (\= [1 4 9 16 25] (map (fn [x] (* x x)) [1 2 3 4 5]))\\r\\n\\r\\n  \\"Or use the names of existing functions\\"\\r\\n  (\= [false false true false false] (map nil? [\:a \:b nil \:c \:d]))\\r\\n\\r\\n  \\"A filter can be strong\\"\\r\\n  (\= '() (filter (fn [x] false) '(\:anything \:goes \:here)))\\r\\n\\r\\n  \\"Or very weak\\"\\r\\n  (\= '(\:anything \:goes \:here) (filter (fn [x] true) '(\:anything \:goes \:here)))\\r\\n\\r\\n  \\"Or somewhere in between\\"\\r\\n  (\= [10 20 30] (filter (fn [x] (< x 31)) [10 20 30 40 50 60 70 80]))\\r\\n\\r\\n  \\"Maps and filters may be combined\\"\\r\\n  (\= [10 20 30] (map (fn [x] (* x 10)) (filter (fn [x] (< x 4)) [1 2 3 4 5 6 7 8])))\\r\\n\\r\\n  \\"Reducing can increase the result\\"\\r\\n  (\= 24 (reduce (fn [a b] (* a b)) [1 2 3 4]))\\r\\n\\r\\n  \\"You can start somewhere else\\"\\r\\n  (\= 2400 (reduce (fn [a b] (* a b)) 100 [1 2 3 4]))\\r\\n\\r\\n  \\"Numbers are not the only things one can reduce\\"\\r\\n  (\= \\"longest\\" (reduce (fn [a b]\\r\\n                         (if (< (count a) (count b)) b a))\\r\\n                       [\\"which\\" \\"word\\" \\"is\\" \\"longest\\"])))" "(inc 5)" "(defn recursive-reverse [coll]\\r\\n  (conj (first coll) (recursive-reverse (rest coll))))" "(recursive-reverse [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty coll)\\r\\n    coll\\r\\n    (conj (first coll) (recursive-reverse (rest coll)))))" "(recursive-reverse [1 2 3 4 5])" "(empty [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    coll\\r\\n    (conj (first coll) (recursive-reverse (rest coll)))))" "(recursive-reverse [1])" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    coll\\r\\n    (conj (recursive-reverse (rest coll)) (first coll))))" "(recursive-reverse [1 2 3 4 5])" "(conj '(1 2 3) 4)" "(conj 4 '(1 2 3))" "(cons 4 '(1 2 3))" "(conj '(1 2 3) '(4 5 6))" "(defn recursive-reverse [coll]\\r\\n  (if (empty? coll)\\r\\n    '()\\r\\n    (concat (recursive-reverse (rest coll)) (first coll))))" "(recursive-reverse [1])" "(factorial 100003N)" "\\r\\n(defn factorial [n]\\r\\n  (if (\= n 1)\\r\\n    1\\r\\n    (* n (factorial (dec n)))))" "(factorial 100003N)" "((fn [[a b]] (str b a))\\r\\n         [\:foo \:bar])" "((fn [[a b c]] (str \\"First come \\" a \\", then comes \\" b \\", then comes \\" c \\" with baby carriage\\"))\\r\\n      [\\"love\\" \\"marriage\\" \\"Clojure\\"])" "((fn [[a b c]] (str \\"First comes \\" a \\", then comes \\" b \\", then comes \\" c \\" with baby carriage\\"))\\r\\n      [\\"love\\" \\"marriage\\" \\"Clojure\\"])" "(str \\"First comes love, \\"\\r\\n          \\"then comes marriage, \\"\\r\\n          \\"then comes Clojure with the baby carriage\\")" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name last-name (clojure.string/join aliases \\" aka \\")))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name last-name (clojure.string/join \\" aka \\" aliases)))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name \\" \\" last-name (clojure.string/join \\" aka \\" aliases)))" "(let [[first-name last-name & aliases]\\r\\n           (list \\"Rich\\" \\"Hickey\\" \\"The Clojurer\\" \\"Go Time\\" \\"Macro Killah\\")]\\r\\n       (str first-name \\" \\" last-name \\" \\" (clojure.string/join \\" aka \\" aliases)))" "(let [{street-address \:street-address, city \:city, state \:state} test-address]\\r\\n       (str (clojure.string/join \\", \\" [street-address city state])))" "(let [{\:keys [street-address city state]} test-address]\\r\\n       (clojure.string/join \\", \\" (map (fn [a] (test-address a)))))" "(def test-address\\r\\n  {\:street-address \\"123 Test Lane\\"\\r\\n   \:city \\"Testerville\\"\\r\\n   \:state \\"TX\\"})" "(let [{\:keys [street-address city state]} test-address]\\r\\n       (clojure.string/join \\", \\" (map (fn [a] (test-address a)))))" "(str [\\"Test\\" \\"Testerson\\"] test-address)" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\r\\n          (clojure.string/join \\", \\"(\:values test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\"(\:values test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\" (vals test-address)))" "(str (clojure.string/join \\" \\" [\\"Test\\" \\"Testerson\\"]) \\", \\" \\r\\n          (clojure.string/join \\", \\" (sort (vals test-address))))" "(let [exclamator (fn [x] (str x \\"\!\\"))]\\r\\n          (dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world)" "(def the-world (ref \\"hello\\"))\\r\\n(def bizarro-world (ref {}))" "(dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world" "(let [exclamator (fn [x] (str x \\"\!\\"))]\\r\\n          (dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world)" "(def the-world (ref \\"hello\\"))" "(let [exclamator (fn [x] (str x \\"\!\\"))]\\r\\n          (dosync\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator)\\r\\n           (alter the-world exclamator))\\r\\n          @the-world)" "(do\\r\\n         (dosync\\r\\n          (ref-set the-world {})\\r\\n          (alter the-world assoc \:jerry \\"Real Jerry\\")\\r\\n          (alter bizarro-world assoc \:jerry \\"Bizarro Jerry\\")\\r\\n          (concat (@the-world \:jerry) (@bizarro-world \:jerry))))" "(dosync\\r\\n          (ref-set the-world {})\\r\\n          (alter the-world assoc \:jerry \\"Real Jerry\\")\\r\\n          (alter bizarro-world assoc \:jerry \\"Bizarro Jerry\\")\\r\\n          [concat (@the-world \:jerry) (@bizarro-world \:jerry)])" "(do\\r\\n          (compare-and-set\! atomic-clock 100 \:fin)\\r\\n          @atomic-clock)" "(def atomic-clock (atom 0))" "(do\\r\\n          (compare-and-set\! atomic-clock 100 \:fin)\\r\\n          @atomic-clock)" "(defmacro r-infix [form]\\r\\n  (cond (not (seq? form))\\r\\n        form\\r\\n        (\= 1 (count form))\\r\\n        `(r-infix ~(first form))\\r\\n        \:else\\r\\n        (let [operator (second form)\\r\\n              first-arg (first form)\\r\\n              others (nth form 2)]\\r\\n          `(~operator\\r\\n            (r-infix ~first-arg)\\r\\n            (r-infix ~others)))))" "(r-infix (10 + (2 * 3) + (4 * 5)))" "(deftype Pulitzer [prize])" "(\:prize (Pulitzer. \\"poetry\\"))" "(with-out-str (present (Oscar. \\"Best Picture\\") \\"Evil Alien Conquerors\\"))" "(defprotocol Award\\r\\n  (present [this recipient]))\\r\\n\\r\\n(defrecord Oscar [category]\\r\\n  Award\\r\\n  (present [this recipient]\\r\\n    (print (str \\"Congratulations on your \\"\\r\\n                (\:category this) \\" Oscar, \\"\\r\\n                recipient\\r\\n                \\"\!\\"))))" "(with-out-str (present (Oscar. \\"Best Picture\\") \\"Evil Alien Conquerors\\"))" "(javadoc \\"warfare\\")" "(class \\"warfare\\")" "$(Math/pow 2 10)" "(Math/pow 2 10)" "(partition 3 [\:a \:b \:c \:d \:e])" "(partition-all 3 (range 5))" "(partition 3 '(0 5 10) (range 13))" "(partition 3 5 (range 13))" "(partition 3 3 [\:this \:are \\"my\\" \\"words\\"] (range 7)\\n           )" "(even? 2)" "(some even? [1 3 2])" "(apply \#(* 2) [1 2 3])" "(apply \#(* 2 %) [1 2 3])" "(apply \#(* 2 %1) [1 2 3])" "(apply \#(* 2 %) 1 2 3)" "(apply \#(* 2 %) (1 2 3))" "(apply \#(* 2 %) 1)" "(apply \#(* 2 %1) 1)" "(- (+(*3 8.8) (* 4 7.66)) 57.5)" "(- (+ (*3 8.8) (* 4 7.66)) 57.5)" "(- (+ (* 3 8.8) (* 4 7.66)) 57.5)" "(- (+ (* 3 8.8) (* 4 7.66M)) 57.5)" "(- (+ (* 3 8.8M) (* 4 7.66M)) 57.50M)"]
eclipse.preferences.version=1
